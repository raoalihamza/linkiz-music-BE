import path from "path";
import fs from "fs";
import { fileURLToPath } from "url";
import ytDlp from "yt-dlp-exec";

// Get current directory
const __dirname = path.dirname(fileURLToPath(import.meta.url));

/**
 * Sleep/delay utility for retry logic
 * @param {number} ms - Milliseconds to wait
 * @returns {Promise}
 */
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Retry wrapper with exponential backoff
 * @param {Function} fn - Async function to retry
 * @param {number} maxRetries - Maximum retry attempts (default: 3)
 * @param {number} baseDelay - Base delay in ms (default: 2000)
 * @returns {Promise<any>}
 */
async function retryWithBackoff(fn, maxRetries = 3, baseDelay = 2000) {
  let lastError;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`üîÑ Attempt ${attempt}/${maxRetries}...`);
      return await fn();
    } catch (error) {
      lastError = error;
      const errorMessage = error.message || error.toString();

      // Check if it's a bot detection error
      const isBotError =
        errorMessage.includes("bot") ||
        errorMessage.includes("Sign in to confirm") ||
        errorMessage.includes("429") ||
        errorMessage.includes("Too Many Requests");

      // If it's the last attempt or not a retryable error, throw immediately
      if (attempt === maxRetries || !isBotError) {
        console.error(`‚ùå Attempt ${attempt} failed (final):`, errorMessage);
        throw error;
      }

      // Calculate exponential backoff: 2s, 4s, 8s, etc.
      const delay = Math.min(baseDelay * Math.pow(2, attempt - 1), 30000); // Max 30s
      console.warn(`‚ö†Ô∏è Attempt ${attempt} failed: ${errorMessage}`);
      console.log(`‚è≥ Waiting ${delay}ms before retry...`);
      await sleep(delay);
    }
  }

  throw lastError;
}

/**
 * Convert JSON cookies to Netscape format
 * @param {Array} jsonCookies
 * @returns {string} Netscape formatted cookies
 */
function jsonToNetscape(jsonCookies) {
  let netscape =
    "# Netscape HTTP Cookie File\n# This file is generated by the application. Do not edit.\n\n";

  jsonCookies.forEach((cookie) => {
    const domain = cookie.domain.startsWith(".")
      ? cookie.domain
      : `.${cookie.domain}`;
    const includeSubdomains = domain.startsWith(".") ? "TRUE" : "FALSE";
    const path = cookie.path || "/";
    const secure = cookie.secure ? "TRUE" : "FALSE";
    const expiration = cookie.expirationDate
      ? Math.round(cookie.expirationDate)
      : 0;

    netscape += `${domain}\t${includeSubdomains}\t${path}\t${secure}\t${expiration}\t${cookie.name}\t${cookie.value}\n`;
  });

  return netscape;
}

/**
 * Ensure valid cookies.txt exists from cookies.json
 * @returns {string|undefined} Path to cookies.txt or undefined
 */
function getCookiesPath() {
  const jsonPath = path.join(__dirname, "../../cookies.json");
  const txtPath = path.join(__dirname, "../../cookies.txt");

  if (!fs.existsSync(jsonPath)) {
    console.warn("‚ö†Ô∏è cookies.json not found - yt-dlp will run without cookies");
    return undefined;
  }

  try {
    // Read JSON cookies
    const jsonContent = fs.readFileSync(jsonPath, "utf8");
    const cookies = JSON.parse(jsonContent);

    // Convert to Netscape format
    const netscapeContent = jsonToNetscape(cookies);
    fs.writeFileSync(txtPath, netscapeContent);

    console.log("‚úÖ Cookies loaded successfully");
    return txtPath;
  } catch (error) {
    console.warn("‚ö†Ô∏è Failed to convert cookies:", error.message);
    return undefined;
  }
}

/**
 * Sanitize filename for Windows compatibility
 * Removes invalid characters and limits length
 * @param {string} filename
 * @returns {string} Safe filename
 */
function sanitizeFilename(filename) {
  if (!filename) return "video";

  // Replace Windows-invalid characters: < > : " / \ | ? *
  let safe = filename
    .replace(/[<>:"/\\|?*]/g, "-") // Replace invalid chars with dash
    .replace(/\s+/g, " ") // Normalize whitespace
    .replace(/\.+/g, ".") // Normalize dots
    .trim();

  // Limit length (Windows has 260 char path limit, leave room for prefix/suffix)
  const maxLength = 100;
  if (safe.length > maxLength) {
    safe = safe.substring(0, maxLength).trim();
  }

  return safe || "video";
}

/**
 * Validate Media URL (YouTube, Instagram, Facebook, TikTok, SoundCloud, Spotify)
 * @param {string} url
 * @returns {boolean}
 */
export function isValidMediaUrl(url) {
  const patterns = [
    // YouTube: youtube.com, youtu.be, youtube.com/shorts
    /^(https?:\/\/)?(www\.)?(youtube\.com|youtu\.be)\/.+$/,

    // Instagram: www, ddinstagram for embeds, /p/ for posts, /reel/ or /reels/ for reels, /tv/ for IGTV
    /^(https?:\/\/)?(www\.|dd)?instagram\.com\/(p|reels?|tv)\/.+$/,

    // Facebook: www, web, m subdomains, fb.watch short links
    /^(https?:\/\/)?(www\.|web\.|m\.)?(facebook\.com|fb\.watch)\/.+$/,

    // TikTok: tiktok.com, vm.tiktok.com (mobile share), vt.tiktok.com (regional share)
    /^(https?:\/\/)?(www\.)?(tiktok\.com|vm\.tiktok\.com|vt\.tiktok\.com)\/.+$/,

    // SoundCloud
    /^(https?:\/\/)?(www\.)?soundcloud\.com\/.+$/,

    // Spotify
    /^(https?:\/\/)?(open\.)?spotify\.com\/.+$/,
  ];
  return patterns.some((pattern) => pattern.test(url));
}

/**
 * Extract video ID from URL for smart caching
 * @param {string} url
 * @returns {string} - Video ID or hash of URL
 */
function getVideoId(url) {
  try {
    // YouTube
    if (url.includes("youtube.com") || url.includes("youtu.be")) {
      const urlObj = new URL(url);
      if (url.includes("youtu.be")) {
        return urlObj.pathname.slice(1).split("?")[0];
      }
      return urlObj.searchParams.get("v") || "unknown";
    }

    // Instagram - extract from path
    if (url.includes("instagram.com")) {
      const match = url.match(/\/(p|reel|tv)\/([A-Za-z0-9_-]+)/);
      return match ? match[2] : "unknown";
    }

    // TikTok
    if (url.includes("tiktok.com")) {
      const match = url.match(/video\/(\d+)/);
      return match ? match[1] : "unknown";
    }

    // Spotify
    if (url.includes("spotify.com")) {
      const match = url.match(/track\/([A-Za-z0-9]+)/);
      return match ? `spotify_${match[1]}` : "spotify_unknown";
    }

    // For other platforms, use a simple hash
    return Buffer.from(url)
      .toString("base64")
      .slice(0, 16)
      .replace(/[^a-zA-Z0-9]/g, "");
  } catch (e) {
    // Fallback to timestamp if ID extraction fails
    return `fallback_${Date.now()}`;
  }
}

/**
 * Resolve shortened URLs (like vt.tiktok.com) to full URLs
 * @param {string} shortUrl
 * @returns {Promise<string>}
 */
async function resolveRedirect(shortUrl) {
  try {
    const response = await fetch(shortUrl, {
      method: "HEAD",
      redirect: "follow", // Follow redirects automatically
      headers: {
        "User-Agent":
          "Mozilla/5.0 (iPhone; CPU iPhone OS 14_8 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1",
      },
    });
    return response.url;
  } catch (error) {
    console.warn("Failed to resolve redirect:", error.message);
    return shortUrl; // Return original if fail
  }
}

/**
 * Get video metadata using yt-dlp with retry logic
 * @param {string} url
 * @returns {Promise<Object>}
 */
export async function getVideoInfo(url) {
  return retryWithBackoff(
    async () => {
      try {
        const cookiesPath = getCookiesPath();
        let cleanUrl = url;
        let spotifyMetadata = null;

        // Handle Spotify track info
        if (url.includes("spotify.com")) {
          console.log("Detected Spotify URL, fetching metadata...");
          const { getSpotifyMetadata } = await import("./spotifyHelper.js");
          spotifyMetadata = await getSpotifyMetadata(url);
          // Search on YouTube for the track
          cleanUrl = `ytsearch1:${spotifyMetadata.artist} - ${spotifyMetadata.title}`;
          console.log(`Searching YouTube for: ${cleanUrl}`);
        }

        // Apply specific cleaning for YouTube to remove playlists
        if (url.includes("youtube.com") || url.includes("youtu.be")) {
          try {
            const urlObj = new URL(url);
            urlObj.searchParams.delete("list");
            urlObj.searchParams.delete("index");
            urlObj.searchParams.delete("pp");
            cleanUrl = urlObj.toString();
          } catch (e) {
            // invalid url, let yt-dlp handle error
          }
        }

        // Resolve TikTok shortened URLs
        if (url.includes("vt.tiktok.com") || url.includes("vm.tiktok.com")) {
          console.log("Resolving TikTok short link...");
          const resolved = await resolveRedirect(url);
          // Clean query parameters to match the working standard URL format
          try {
            const urlObj = new URL(resolved);
            urlObj.search = ""; // Remove all query params (?_r=1, etc)
            cleanUrl = urlObj.toString();
            console.log("Cleaned resolved URL:", cleanUrl);
          } catch (e) {
            cleanUrl = resolved;
          }
        }

        const flags = {
          dumpSingleJson: true,
          noWarnings: true,
          noPlaylist: true,
          cookies: cookiesPath, // Enable cookies for ALL platforms including TikTok
        };

        // Use yt-dlp to get JSON info with optimized flags
        let output = await ytDlp(cleanUrl, flags, {
          maxBuffer: 1024 * 1024 * 10, // Increase buffer to 10MB to prevent crash on large JSON
        });

        // If it was a search (Spotify fallback), extract the first result
        if (output.entries && output.entries.length > 0) {
          output = output.entries[0];
        }

        // Use Spotify metadata if available, otherwise use yt-dlp output
        const platform = spotifyMetadata
          ? "spotify"
          : output.extractor_key
            ? output.extractor_key.toLowerCase()
            : "unknown";
        let qualities = extractAvailableQualities(output.formats);

        // Restriction: Spotify and SoundCloud only provide audio formats
        if (platform === "spotify" || platform === "soundcloud") {
          qualities.video = [];
        }

        return {
          title: spotifyMetadata
            ? sanitizeFilename(spotifyMetadata.title)
            : sanitizeFilename(output.title || "Unknown Title"),
          author: spotifyMetadata
            ? spotifyMetadata.artist
            : output.uploader || output.channel || "Unknown Author",
          thumbnail: output.thumbnail || "",
          duration: output.duration
            ? `${Math.floor(output.duration / 60)}:${(output.duration % 60).toString().padStart(2, "0")}`
            : "Unknown",
          platform: platform,
          qualities: qualities,
        };
      } catch (error) {
        console.error("Error fetching video info:", error.message);

        // Enhance error message for bot detection
        if (
          error.message.includes("bot") ||
          error.message.includes("Sign in to confirm")
        ) {
          throw new Error(
            "YouTube bot detection triggered. Cookies may need refresh. Please try again or contact support.",
          );
        }

        throw new Error("Failed to fetch video information");
      }
    },
    3,
    2000,
  ); // 3 retries, 2s base delay
}

/**
 * Extract available video/audio qualities from formats array
 * @param {Array} formats
 * @returns {Object} - { video: ['4k', '1080p', '720p'], audio: [...] }
 */
function extractAvailableQualities(formats) {
  if (!formats || formats.length === 0) {
    return { video: [], audio: [] };
  }

  const videoFormats = formats.filter((f) => f.height && f.vcodec !== "none");
  const heights = [...new Set(videoFormats.map((f) => f.height))].sort(
    (a, b) => b - a,
  );

  const uniqueVideoQualities = [];
  heights.forEach((h) => {
    if (h >= 2160) uniqueVideoQualities.push("4k");
    else if (h >= 1080 && !uniqueVideoQualities.includes("1080p"))
      uniqueVideoQualities.push("1080p");
    else if (h >= 720 && !uniqueVideoQualities.includes("720p"))
      uniqueVideoQualities.push("720p");
  });

  // Audio Qualities (Standard set for now, as we re-encode audio)
  const audioQualities = ["320kbps", "192kbps", "128kbps"];

  return {
    video: uniqueVideoQualities, // e.g. ['4k', '1080p', '720p']
    audio: audioQualities,
  };
}

/**
 * Get direct download link for free platforms (IG, FB, TikTok) with retry logic
 * Returns the direct .mp4/.webm URL without downloading to server
 * @param {string} url
 * @param {string} format - 'audio' or 'video'
 * @returns {Promise<{ downloadUrl: string, title: string, fileSize: string }>}
 */
export async function getDirectDownloadLink(url, format = "video") {
  return retryWithBackoff(
    async () => {
      try {
        const cookiesPath = getCookiesPath();

        console.log(`‚ö° [Direct Link] Extracting ${format} URL for: ${url}`);

        // Use yt-dlp to get the direct download URL
        const output = await ytDlp(
          url,
          {
            dumpSingleJson: true,
            noWarnings: true,
            noPlaylist: true,
            cookies: cookiesPath,
          },
          {
            maxBuffer: 1024 * 1024 * 10,
          },
        );

        let downloadUrl = output.url;
        let selectedFormat = null;

        // If formats array exists, find the best format
        if (output.formats && output.formats.length > 0) {
          if (format === "audio") {
            // Find best audio-only format
            selectedFormat = output.formats
              .filter((f) => f.acodec !== "none" && f.vcodec === "none") // Audio only
              .sort((a, b) => (b.abr || 0) - (a.abr || 0))[0]; // Sort by audio bitrate

            // If no audio-only format, extract from video+audio format
            if (!selectedFormat) {
              selectedFormat = output.formats
                .filter((f) => f.acodec !== "none") // Has audio
                .sort((a, b) => (b.abr || 0) - (a.abr || 0))[0];
            }
          } else {
            // Find best format with both video and audio
            selectedFormat =
              output.formats
                .filter((f) => f.vcodec !== "none" && f.acodec !== "none") // Has both
                .sort((a, b) => (b.filesize || 0) - (a.filesize || 0))[0] || // Sort by file size
              output.formats[output.formats.length - 1]; // Fallback
          }

          downloadUrl = selectedFormat?.url || output.url;
        }

        // Try to get file size from metadata
        let fileSize = selectedFormat?.filesize || output.filesize;

        // If no filesize in metadata, try HEAD request
        if (!fileSize && downloadUrl) {
          try {
            const headResponse = await fetch(downloadUrl, { method: "HEAD" });
            const contentLength = headResponse.headers.get("content-length");
            if (contentLength) {
              fileSize = parseInt(contentLength);
            }
          } catch (e) {
            console.warn(
              "Could not fetch file size via HEAD request:",
              e.message,
            );
          }
        }

        return {
          downloadUrl,
          title: sanitizeFilename(output.title || "media"),
          fileSize: fileSize
            ? `${(fileSize / 1024 / 1024).toFixed(2)} MB`
            : "Unknown",
          duration: output.duration
            ? `${Math.floor(output.duration / 60)}:${(output.duration % 60).toString().padStart(2, "0")}`
            : "Unknown",
        };
      } catch (error) {
        console.error("‚ùå [Direct Link] Error:", error.message);

        // Enhance error message for bot detection
        if (
          error.message.includes("bot") ||
          error.message.includes("Sign in to confirm")
        ) {
          throw new Error(
            "Platform bot detection triggered. Please try again in a few minutes.",
          );
        }

        throw new Error("Failed to extract download link");
      }
    },
    3,
    2000,
  ); // 3 retries, 2s base delay
}

/**
 * Download Media using yt-dlp with retry logic (with Smart Caching)
 * @param {string} url
 * @param {string} format 'audio' or 'video'
 * @param {string} qualityTarget 'best' (1080p+), 'standard' (720p/1080p)
 * @returns {Promise<{ filePath: string, title: string }>}
 */
export async function downloadMedia(
  url,
  format = "audio",
  qualityTarget = "best",
) {
  return retryWithBackoff(
    async () => {
      const tempDir = path.join(__dirname, "../../temp");

      // Ensure temp directory exists
      if (!fs.existsSync(tempDir)) {
        fs.mkdirSync(tempDir, { recursive: true });
      }

      // Resolve TikTok short links
      if (url.includes("vt.tiktok.com") || url.includes("vm.tiktok.com")) {
        console.log("Resolving TikTok short link for download...");
        const resolved = await resolveRedirect(url);
        try {
          const urlObj = new URL(resolved);
          urlObj.search = "";
          url = urlObj.toString();
          console.log("Cleaned resolved URL:", url);
        } catch (e) {
          url = resolved;
        }
      }

      let cleanUrl = url;
      let spotifyMetadata = null;

      // Handle Spotify track download
      if (url.includes("spotify.com")) {
        console.log("Detected Spotify URL for download, fetching metadata...");
        const { getSpotifyMetadata } = await import("./spotifyHelper.js");
        spotifyMetadata = await getSpotifyMetadata(url);
        // Search on YouTube and download the first result
        cleanUrl = `ytsearch1:${spotifyMetadata.artist} - ${spotifyMetadata.title}`;
        console.log(`Searching and downloading from YouTube: ${cleanUrl}`);
      }

      // Generate video ID for caching
      const videoId = getVideoId(url);
      const cookiesPath = getCookiesPath();

      // Cleanup URL specifically for YouTube to avoid playlist issues
      if (url.includes("youtube.com") || url.includes("youtu.be")) {
        try {
          const urlObj = new URL(url);
          urlObj.searchParams.delete("list");
          urlObj.searchParams.delete("index");
          urlObj.searchParams.delete("pp");
          cleanUrl = urlObj.toString();
        } catch (e) {
          // ignore
        }
      }

      // === SMART CACHING: Check if we already downloaded this video IN THIS QUALITY ===
      // We include qualityTarget to distinguish between 4k, best (1080p), and standard (720p)
      const cachedFiles = fs
        .readdirSync(tempDir)
        .filter((file) => file.startsWith(`${videoId}_${qualityTarget}_`));

      if (cachedFiles.length > 0) {
        // Found cached file! Reuse it
        const cachedFile = cachedFiles[0];
        const filePath = path.join(tempDir, cachedFile);
        console.log(
          `üöÄ [CACHE HIT] Reusing existing download (${qualityTarget}): ${cachedFile}`,
        );

        return {
          filePath,
          title: cachedFile
            .replace(`${videoId}_${qualityTarget}_`, "")
            .split(".")
            .slice(0, -1)
            .join("."),
        };
      }

      // === NO CACHE: Download fresh ===
      console.log(
        `üì• [CACHE MISS] Downloading fresh (${qualityTarget}): ${videoId}`,
      );

      // Use Spotify title for filename if available
      const filenameTemplate = spotifyMetadata
        ? sanitizeFilename(spotifyMetadata.title)
        : "%(title).100B";
      const outputTemplate = path.join(
        tempDir,
        `${videoId}_${qualityTarget}_${filenameTemplate}.%(ext)s`,
      );

      const options = {
        output: outputTemplate,
        noWarnings: true,
        noPlaylist: true, // Critical: Ensure we only download the video, not the playlist
        cookies: cookiesPath,
        restrictFilenames: true, // Restrict filenames to ASCII and avoid special characters
      };

      // Configure format options
      if (format === "audio") {
        options.format = "bestaudio";
      } else {
        // === QUALITY SELECTION STRATEGY ===
        // 'best' = Try to get 1440p/2K/4K if available (Overshooting for crisp 1080p result)
        // 'standard' = Try to get 1080p (Overshooting for crisp 720p result)

        if (qualityTarget === "4k") {
          // === PRO MODE (4K/2K/8K) ===
          // Just get the absolute best, regardless of codec (likely AV1/VP9).
          // Max Quality, but might need VLC to play.
          options.format = "bestvideo+bestaudio/best";
        } else if (qualityTarget === "best") {
          // === COMPATIBILITY MODE (1080p) ===
          // Get absolute best available but PREFER H.264 video + AAC audio for MAX compatibility
          // Order: 1. H264+AAC (Perfect), 2. H264+Any (Good video), 3. Any+AAC, 4. Best Available
          options.format =
            "bestvideo[vcodec^=avc1]+bestaudio[acodec^=mp4a]/bestvideo[vcodec^=avc1]+bestaudio/bestvideo+bestaudio/best";
        } else {
          // 'standard' (mapped to 720p request)
          // Limit to 720p max to ensure file size difference compared to 1080p
          options.format =
            "bestvideo[height<=720][vcodec^=avc1]+bestaudio[acodec^=mp4a]/bestvideo[height<=720][vcodec^=avc1]+bestaudio/bestvideo[height<=720]+bestaudio/best";
        }

        options.mergeOutputFormat = "mp4"; // This triggers the fast ffmpeg merge
      }

      try {
        console.log(`üé¨ [yt-dlp] Starting download: ${cleanUrl}`);

        // yt-dlp-exec returns a promise that resolves when the process exits
        await ytDlp(cleanUrl, options);

        // Find the downloaded file
        const files = fs.readdirSync(tempDir);
        // Look for files starting with our videoId and qualityTarget
        const downloadedFile = files.find((file) =>
          file.startsWith(`${videoId}_${qualityTarget}_`),
        );

        if (!downloadedFile) {
          throw new Error("Download finished but file not found");
        }

        const filePath = path.join(tempDir, downloadedFile);
        console.log(`‚úÖ [yt-dlp] Download complete: ${filePath}`);

        return {
          filePath,
          title: downloadedFile
            .replace(`${videoId}_${qualityTarget}_`, "")
            .split(".")
            .slice(0, -1)
            .join("."),
        };
      } catch (error) {
        console.error("‚ùå [yt-dlp] Download Error:", error.message);

        // Enhance error message for bot detection
        if (
          error.message.includes("bot") ||
          error.message.includes("Sign in to confirm")
        ) {
          throw new Error(
            "YouTube bot detection triggered. Please try again in a few minutes or contact support.",
          );
        }

        throw new Error("Failed to download video");
      }
    },
    3,
    3000,
  ); // 3 retries, 3s base delay for downloads
}
