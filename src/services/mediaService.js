import path from 'path';
import fs from 'fs';
import { fileURLToPath } from 'url';
import ytDlp from 'yt-dlp-exec';

// Get current directory
const __dirname = path.dirname(fileURLToPath(import.meta.url));

/**
 * Convert JSON cookies to Netscape format
 * @param {Array} jsonCookies 
 * @returns {string} Netscape formatted cookies
 */
function jsonToNetscape(jsonCookies) {
  let netscape = '# Netscape HTTP Cookie File\n# This file is generated by the application. Do not edit.\n\n';
  
  jsonCookies.forEach(cookie => {
    const domain = cookie.domain.startsWith('.') ? cookie.domain : `.${cookie.domain}`;
    const includeSubdomains = domain.startsWith('.') ? 'TRUE' : 'FALSE';
    const path = cookie.path || '/';
    const secure = cookie.secure ? 'TRUE' : 'FALSE';
    const expiration = cookie.expirationDate ? Math.round(cookie.expirationDate) : 0;
    
    netscape += `${domain}\t${includeSubdomains}\t${path}\t${secure}\t${expiration}\t${cookie.name}\t${cookie.value}\n`;
  });
  
  return netscape;
}

/**
 * Ensure valid cookies.txt exists from cookies.json
 * @returns {string|undefined} Path to cookies.txt or undefined
 */
function getCookiesPath() {
  const jsonPath = path.join(__dirname, '../../cookies.json');
  const txtPath = path.join(__dirname, '../../cookies.txt');

  if (!fs.existsSync(jsonPath)) return undefined;

  try {
    // Read JSON cookies
    const jsonContent = fs.readFileSync(jsonPath, 'utf8');
    const cookies = JSON.parse(jsonContent);

    // Convert to Netscape format
    const netscapeContent = jsonToNetscape(cookies);
    fs.writeFileSync(txtPath, netscapeContent);

    return txtPath;
  } catch (error) {
    console.warn('Failed to convert cookies:', error.message);
    return undefined;
  }
}

/**
 * Sanitize filename for Windows compatibility
 * Removes invalid characters and limits length
 * @param {string} filename 
 * @returns {string} Safe filename
 */
function sanitizeFilename(filename) {
  if (!filename) return 'video';
  
  // Replace Windows-invalid characters: < > : " / \ | ? *
  let safe = filename
    .replace(/[<>:"/\\|?*]/g, '-')  // Replace invalid chars with dash
    .replace(/\s+/g, ' ')            // Normalize whitespace
    .replace(/\.+/g, '.')            // Normalize dots
    .trim();
  
  // Limit length (Windows has 260 char path limit, leave room for prefix/suffix)
  const maxLength = 100;
  if (safe.length > maxLength) {
    safe = safe.substring(0, maxLength).trim();
  }
  
  return safe || 'video';
}

/**
 * Validate Media URL (YouTube, Instagram, Facebook, TikTok, SoundCloud, Spotify)
 * @param {string} url 
 * @returns {boolean}
 */
export function isValidMediaUrl(url) {
  const patterns = [
    // YouTube: youtube.com, youtu.be, youtube.com/shorts
    /^(https?:\/\/)?(www\.)?(youtube\.com|youtu\.be)\/.+$/,
    
    // Instagram: www, ddinstagram for embeds, /p/ for posts, /reel/ or /reels/ for reels, /tv/ for IGTV
    /^(https?:\/\/)?(www\.|dd)?instagram\.com\/(p|reels?|tv)\/.+$/,
    
    // Facebook: www, web, m subdomains, fb.watch short links
    /^(https?:\/\/)?(www\.|web\.|m\.)?(facebook\.com|fb\.watch)\/.+$/,
    
    // TikTok: tiktok.com, vm.tiktok.com (mobile share), vt.tiktok.com (regional share)
    /^(https?:\/\/)?(www\.)?(tiktok\.com|vm\.tiktok\.com|vt\.tiktok\.com)\/.+$/,
    
    // SoundCloud
    /^(https?:\/\/)?(www\.)?soundcloud\.com\/.+$/,
    
    // Spotify
    /^(https?:\/\/)?(open\.)?spotify\.com\/.+$/
  ];
  return patterns.some(pattern => pattern.test(url));
}

/**
 * Extract video ID from URL for smart caching
 * @param {string} url 
 * @returns {string} - Video ID or hash of URL
 */
function getVideoId(url) {
  try {
    // YouTube
    if (url.includes('youtube.com') || url.includes('youtu.be')) {
      const urlObj = new URL(url);
      if (url.includes('youtu.be')) {
        return urlObj.pathname.slice(1).split('?')[0];
      }
      return urlObj.searchParams.get('v') || 'unknown';
    }
    
    // Instagram - extract from path
    if (url.includes('instagram.com')) {
      const match = url.match(/\/(p|reel|tv)\/([A-Za-z0-9_-]+)/);
      return match ? match[2] : 'unknown';
    }
    
    // TikTok
    if (url.includes('tiktok.com')) {
      const match = url.match(/video\/(\d+)/);
      return match ? match[1] : 'unknown';
    }
    
    // Spotify
    if (url.includes('spotify.com')) {
      const match = url.match(/track\/([A-Za-z0-9]+)/);
      return match ? `spotify_${match[1]}` : 'spotify_unknown';
    }
    
    // For other platforms, use a simple hash
    return Buffer.from(url).toString('base64').slice(0, 16).replace(/[^a-zA-Z0-9]/g, '');
  } catch (e) {
    // Fallback to timestamp if ID extraction fails
    return `fallback_${Date.now()}`;
  }
}

/**
 * Resolve shortened URLs (like vt.tiktok.com) to full URLs
 * @param {string} shortUrl 
 * @returns {Promise<string>}
 */
async function resolveRedirect(shortUrl) {
  try {
    const response = await fetch(shortUrl, {
      method: 'HEAD',
      redirect: 'follow', // Follow redirects automatically
      headers: {
        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_8 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1'
      }
    });
    return response.url;
  } catch (error) {
    console.warn('Failed to resolve redirect:', error.message);
    return shortUrl; // Return original if fail
  }
}

/**
 * Get video metadata using yt-dlp
 * @param {string} url 
 * @returns {Promise<Object>}
 */
export async function getVideoInfo(url) {
  try {
    const cookiesPath = getCookiesPath();
    let cleanUrl = url;
    let spotifyMetadata = null;

    // Handle Spotify track info
    if (url.includes('spotify.com')) {
      console.log('Detected Spotify URL, fetching metadata...');
      const { getSpotifyMetadata } = await import('./spotifyHelper.js');
      spotifyMetadata = await getSpotifyMetadata(url);
      // Search on YouTube for the track
      cleanUrl = `ytsearch1:${spotifyMetadata.artist} - ${spotifyMetadata.title}`;
      console.log(`Searching YouTube for: ${cleanUrl}`);
    }

    // Apply specific cleaning for YouTube to remove playlists
    if (url.includes('youtube.com') || url.includes('youtu.be')) {
      try {
        const urlObj = new URL(url);
        urlObj.searchParams.delete('list');
        urlObj.searchParams.delete('index');
        urlObj.searchParams.delete('pp');
        cleanUrl = urlObj.toString();
      } catch (e) {
        // invalid url, let yt-dlp handle error
      }
    }
    
    // Resolve TikTok shortened URLs
    if (url.includes('vt.tiktok.com') || url.includes('vm.tiktok.com')) {
      console.log('Resolving TikTok short link...');
      const resolved = await resolveRedirect(url);
      // Clean query parameters to match the working standard URL format
      try {
        const urlObj = new URL(resolved);
        urlObj.search = ''; // Remove all query params (?_r=1, etc)
        cleanUrl = urlObj.toString();
        console.log('Cleaned resolved URL:', cleanUrl);
      } catch (e) {
        cleanUrl = resolved;
      }
    }
    
    const flags = {
      dumpSingleJson: true,
      noWarnings: true,
      noPlaylist: true,
      cookies: cookiesPath, // Enable cookies for ALL platforms including TikTok
    };

    // Remove manual header overrides for TikTok - reliance on cookies and native yt-dlp behavior is better
    // URL resolution is still kept above
    
    // 2. Use yt-dlp to get JSON info with optimized flags
    let output = await ytDlp(cleanUrl, flags, {
      maxBuffer: 1024 * 1024 * 10 // Increase buffer to 10MB to prevent crash on large JSON
    });

    // If it was a search (Spotify fallback), extract the first result
    if (output.entries && output.entries.length > 0) {
      output = output.entries[0];
    }

    // Use Spotify metadata if available, otherwise use yt-dlp output
    const platform = spotifyMetadata ? 'spotify' : (output.extractor_key ? output.extractor_key.toLowerCase() : 'unknown');
    let qualities = extractAvailableQualities(output.formats);

    // Restriction: Spotify and SoundCloud only provide audio formats
    if (platform === 'spotify' || platform === 'soundcloud') {
      qualities.video = [];
    }

    return {
      title: spotifyMetadata ? sanitizeFilename(spotifyMetadata.title) : sanitizeFilename(output.title || 'Unknown Title'),
      author: spotifyMetadata ? spotifyMetadata.artist : (output.uploader || output.uploader_id || 'Unknown Artist'),
      duration: spotifyMetadata ? spotifyMetadata.duration : (output.duration || 0),
      thumbnail: spotifyMetadata ? spotifyMetadata.thumbnail : (output.thumbnail || (output.thumbnails && output.thumbnails.length > 0 ? output.thumbnails[output.thumbnails.length - 1].url : null)),
      platform: platform,
      // formats: output.formats, // TOO LARGE to send to frontend directly
      qualities: qualities, // Using filtered qualities
      videoId: output.id || getVideoId(url) // Store video ID for caching
    };
  } catch (error) {
    console.error('Error fetching video info:', error.message);
    throw new Error('Failed to fetch video information');
  }
}

/**
 * Extract unique available qualities from format list
 */
function extractAvailableQualities(formats = []) {
  if (!formats || !formats.length) return { video: [], audio: ['mp3-320', 'mp3-192', 'mp3-128'] };

  // 1. Video Resolutions
  // Filter for video formats that actually have video codec
  const videoFormats = formats.filter(f => f.vcodec !== 'none' && f.height);
  
  // Extract unique heights
  const heights = [...new Set(videoFormats.map(f => f.height))].sort((a, b) => b - a);
  
  // Map to label strings
  const videoQualities = heights.map(h => {
    if (h >= 2160) return '4k';
    if (h >= 1440) return '2k';
    if (h >= 1080) return '1080p';
    if (h >= 720) return '720p';
    if (h >= 480) return '480p';
    return `${h}p`;
  });

  // Deduplicate strings (e.g., multiple 1080p streams)
  const uniqueVideoQualities = [...new Set(videoQualities)];

  // 2. Audio Qualities (Standard set for now, as we re-encode audio)
  const audioQualities = ['320kbps', '192kbps', '128kbps'];

  return {
    video: uniqueVideoQualities, // e.g. ['4k', '1080p', '720p']
    audio: audioQualities
  };
}

/**
 * Get direct download link for free platforms (IG, FB, TikTok)
 * Returns the direct .mp4/.webm URL without downloading to server
 * @param {string} url 
 * @param {string} format - 'audio' or 'video'
 * @returns {Promise<{ downloadUrl: string, title: string, fileSize: string }>}
 */
export async function getDirectDownloadLink(url, format = 'video') {
  try {
    const cookiesPath = getCookiesPath();
    
    console.log(`‚ö° [Direct Link] Extracting ${format} URL for: ${url}`);
    
    // Use yt-dlp to get the direct download URL
    const output = await ytDlp(url, {
      dumpSingleJson: true,
      noWarnings: true,
      noPlaylist: true,
      cookies: cookiesPath,
    }, {
      maxBuffer: 1024 * 1024 * 10
    });

    let downloadUrl = output.url;
    let selectedFormat = null;
    
    // If formats array exists, find the best format
    if (output.formats && output.formats.length > 0) {
      if (format === 'audio') {
        // Find best audio-only format
        selectedFormat = output.formats
          .filter(f => f.acodec !== 'none' && f.vcodec === 'none') // Audio only
          .sort((a, b) => (b.abr || 0) - (a.abr || 0))[0]; // Sort by audio bitrate
        
        // If no audio-only format, extract from video+audio format
        if (!selectedFormat) {
          selectedFormat = output.formats
            .filter(f => f.acodec !== 'none') // Has audio
            .sort((a, b) => (b.abr || 0) - (a.abr || 0))[0];
        }
      } else {
        // Find best format with both video and audio
        selectedFormat = output.formats
          .filter(f => f.vcodec !== 'none' && f.acodec !== 'none') // Has both
          .sort((a, b) => (b.filesize || 0) - (a.filesize || 0))[0] // Sort by file size
          || output.formats[output.formats.length - 1]; // Fallback
      }
      
      downloadUrl = selectedFormat?.url || output.url;
    }

    
    // Try to get file size from metadata
    let fileSize = selectedFormat?.filesize || output.filesize;
    
    // If no filesize in metadata, try HEAD request
    if (!fileSize && downloadUrl) {
      try {
        const headResponse = await fetch(downloadUrl, { method: 'HEAD' });
        const contentLength = headResponse.headers.get('content-length');
        if (contentLength) {
          fileSize = parseInt(contentLength);
        }
      } catch (e) {
        console.warn('Could not fetch file size via HEAD request:', e.message);
      }
    }

    return {
      downloadUrl,
      title: sanitizeFilename(output.title || 'media'),
      fileSize: fileSize 
        ? `${(fileSize / 1024 / 1024).toFixed(2)} MB` 
        : 'Unknown',
      duration: output.duration ? `${Math.floor(output.duration / 60)}:${(output.duration % 60).toString().padStart(2, '0')}` : 'Unknown'
    };
  } catch (error) {
    console.error('‚ùå [Direct Link] Error:', error.message);
    throw new Error('Failed to extract download link');
  }
}

/**
 * Download Media using yt-dlp (with Smart Caching)
 * @param {string} url 
 * @param {string} format 'audio' or 'video'
 * @param {string} qualityTarget 'best' (1080p+), 'standard' (720p/1080p)
 * @returns {Promise<{ filePath: string, title: string }>}
 */
export async function downloadMedia(url, format = 'audio', qualityTarget = 'best') {
  const tempDir = path.join(__dirname, '../../temp');
  
  // Ensure temp directory exists
  if (!fs.existsSync(tempDir)) {
    fs.mkdirSync(tempDir, { recursive: true });
  }

  // Resolve TikTok short links
  if (url.includes('vt.tiktok.com') || url.includes('vm.tiktok.com')) {
      console.log('Resolving TikTok short link for download...');
      const resolved = await resolveRedirect(url);
      try {
        const urlObj = new URL(resolved);
        urlObj.search = ''; 
        url = urlObj.toString();
        console.log('Cleaned resolved URL:', url);
      } catch (e) {
        url = resolved;
      }
  }

  let cleanUrl = url;
  let spotifyMetadata = null;

  // Handle Spotify track download
  if (url.includes('spotify.com')) {
    console.log('Detected Spotify URL for download, fetching metadata...');
    const { getSpotifyMetadata } = await import('./spotifyHelper.js');
    spotifyMetadata = await getSpotifyMetadata(url);
    // Search on YouTube and download the first result
    cleanUrl = `ytsearch1:${spotifyMetadata.artist} - ${spotifyMetadata.title}`;
    console.log(`Searching and downloading from YouTube: ${cleanUrl}`);
  }

  // Generate video ID for caching
  const videoId = getVideoId(url);
  const cookiesPath = getCookiesPath();

  // Cleanup URL specifically for YouTube to avoid playlist issues
  if (url.includes('youtube.com') || url.includes('youtu.be')) {
    try {
      const urlObj = new URL(url);
      urlObj.searchParams.delete('list');
      urlObj.searchParams.delete('index');
      urlObj.searchParams.delete('pp');
      cleanUrl = urlObj.toString();
    } catch (e) {
      // ignore
    }
  }

  // === SMART CACHING: Check if we already downloaded this video IN THIS QUALITY ===
  // We include qualityTarget to distinguish between 4k, best (1080p), and standard (720p)
  const cachedFiles = fs.readdirSync(tempDir).filter(file => file.startsWith(`${videoId}_${qualityTarget}_`));
  
  if (cachedFiles.length > 0) {
    // Found cached file! Reuse it
    const cachedFile = cachedFiles[0];
    const filePath = path.join(tempDir, cachedFile);
    console.log(`üöÄ [CACHE HIT] Reusing existing download (${qualityTarget}): ${cachedFile}`);
    
    return {
      filePath,
      title: cachedFile.replace(`${videoId}_${qualityTarget}_`, '').split('.').slice(0, -1).join('.')
    };
  }

  // === NO CACHE: Download fresh ===
  console.log(`üì• [CACHE MISS] Downloading fresh (${qualityTarget}): ${videoId}`);
  
  // Use Spotify title for filename if available
  const filenameTemplate = spotifyMetadata ? sanitizeFilename(spotifyMetadata.title) : '%(title).100B';
  const outputTemplate = path.join(tempDir, `${videoId}_${qualityTarget}_${filenameTemplate}.%(ext)s`);

  const options = {
    output: outputTemplate,
    noWarnings: true,
    noPlaylist: true, // Critical: Ensure we only download the video, not the playlist
    cookies: cookiesPath,
    restrictFilenames: true, // Restrict filenames to ASCII and avoid special characters
  };

  // Platform specific fixes
  // TikTok manual headers removed to favor cookie-based auth
  
  // Configure format options
  if (format === 'audio') {
    options.format = 'bestaudio';
  } else {
    // === QUALITY SELECTION STRATEGY ===
    // 'best' = Try to get 1440p/2K/4K if available (Overshooting for crisp 1080p result)
    // 'standard' = Try to get 1080p (Overshooting for crisp 720p result)
    
    if (qualityTarget === '4k') {
      // === PRO MODE (4K/2K/8K) ===
      // Just get the absolute best, regardless of codec (likely AV1/VP9).
      // Max Quality, but might need VLC to play.
      options.format = 'bestvideo+bestaudio/best';
    } else if (qualityTarget === 'best') {
      // === COMPATIBILITY MODE (1080p) ===
      // Get absolute best available but PREFER H.264 video + AAC audio for MAX compatibility
      // Order: 1. H264+AAC (Perfect), 2. H264+Any (Good video), 3. Any+AAC, 4. Best Available
      options.format = 'bestvideo[vcodec^=avc1]+bestaudio[acodec^=mp4a]/bestvideo[vcodec^=avc1]+bestaudio/bestvideo+bestaudio/best';
    } else {
      // 'standard' (mapped to 720p request)
      // Limit to 720p max to ensure file size difference compared to 1080p
      options.format = 'bestvideo[height<=720][vcodec^=avc1]+bestaudio[acodec^=mp4a]/bestvideo[height<=720][vcodec^=avc1]+bestaudio/bestvideo[height<=720]+bestaudio/best';
    }
    
    options.mergeOutputFormat = 'mp4'; // This triggers the fast ffmpeg merge
  }

  try {
    console.log(`üé¨ [yt-dlp] Starting download: ${cleanUrl}`);
    
    // yt-dlp-exec returns a promise that resolves when the process exits
    await ytDlp(cleanUrl, options);

    // Find the downloaded file
    const files = fs.readdirSync(tempDir);
    // Look for files starting with our videoId and qualityTarget
    const downloadedFile = files.find(file => file.startsWith(`${videoId}_${qualityTarget}_`));

    if (!downloadedFile) {
      throw new Error('Download finished but file not found');
    }

    const filePath = path.join(tempDir, downloadedFile);
    console.log(`‚úÖ [yt-dlp] Download complete: ${filePath}`);

    return { 
      filePath, 
      title: downloadedFile.replace(`${videoId}_${qualityTarget}_`, '').split('.').slice(0, -1).join('.') 
    };

  } catch (error) {
    console.error('‚ùå [yt-dlp] Download Error:', error.message);
    throw new Error('Failed to download video');
  }
}
